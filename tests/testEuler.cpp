//
// Created by root on 23-11-3.
//

#include <catch2/catch_test_macros.hpp>
#include <iostream>

#include "polyscope/polyscope.h"
#include "polyscope/curve_network.h"
#include "polyscope/surface_mesh.h"
#include "EulerOperation.h"
#include "sweep.h"
#include "utils.h"

inline void compareLoop(std::shared_ptr<Loop> l, const std::vector<Vec3>& results)
{
    auto he = l->halfEdge();
    int i = 0;
    REQUIRE(he->vertex()->pos() == results[i++]);
    for (he = l->halfEdge()->next(); he != l->halfEdge(); he = he->next())
    {
        REQUIRE(he->vertex()->pos() == results[i++]);
    }
}

inline void test_consistency(std::shared_ptr<Solid> S)
{
    for (auto F = S->face(); F != nullptr; F = F->next())
    {
        REQUIRE(F->solid() == S);
        for (auto L = F->loop(); L != nullptr; L = L->next())
        {
            if (L->face() != F)
            {
                L->printLoop();
                F->printLoops();
            }
            REQUIRE(L->face() == F);
        }
    }
}

TEST_CASE("construct a basic square", "[EulerOp]"){
    auto [S, V1] = EulerOp::mvsf({0,0,0});
    auto& lp = S->face()->loop();
    auto he1 = EulerOp::mev({1,0,0}, V1, lp);
    auto V2 = he1->sibling()->vertex();
    auto he2 = EulerOp::mev({1,0,1}, he1->sibling()->vertex(), lp);
    auto he3 = EulerOp::mev({0,0,1}, he2->sibling()->vertex(), lp);
    auto f = EulerOp::mef(V1, he3->sibling()->vertex(), lp);
    compareLoop(f->loop(), {{0,0,1}, {0,0,0}, {1,0,0},{1,0,1}});
    compareLoop(lp, {{0,0,0}, {0,0,1}, {1,0,1}, {1,0,0}});
    test_consistency(S);
}

TEST_CASE("construct a square with a inner square", "[EulerOp]"){
    auto [S, V1] = EulerOp::mvsf({0,0,0});
    auto& lp = S->face()->loop();
    auto he1 = EulerOp::mev({3,0,0}, V1, lp);
    auto V2 = he1->sibling()->vertex();
    auto he2 = EulerOp::mev({3,0,3}, he1->sibling()->vertex(), lp);
    auto he3 = EulerOp::mev({0,0,3}, he2->sibling()->vertex(), lp);
    auto f = EulerOp::mef(V1, he3->sibling()->vertex(), lp);
    auto he4 = EulerOp::mev({1,0,1}, V1, f->loop());
    auto conEdge = S->edge();
    auto he5 = EulerOp::mev({2,0,1}, he4->sibling()->vertex(), f->loop());
    auto he6 = EulerOp::mev({2,0,2}, he5->sibling()->vertex(), f->loop());
    auto he7 = EulerOp::mev({1,0,2}, he6->sibling()->vertex(), f->loop());
    auto f2 = EulerOp::mef(he5->vertex(), he7->sibling()->vertex(), f->loop());
//    S->printFaces();
    compareLoop(f2->loop(), {{1,0,2}, {1,0,1}, {2,0,1}, {2,0,2}});
    compareLoop(f->loop(), {{1,0,1}, {1,0,2}, {2,0,2}, {2,0,1}, {1,0,1},  {0,0,0}, {3,0,0}, {3,0,3}, {0,0,3}, {0,0,0}});
    EulerOp::kemr(conEdge, f->loop());
//    S->printFaces();
    compareLoop(f->loop()->next(), {{1,0,1}, {1,0,2}, {2,0,2}, {2,0,1}});
    compareLoop(f->loop(), {{0,0,0}, {3,0,0}, {3,0,3}, {0,0,3}});
    test_consistency(S);
//    S->printFaces();
}

//TEST_CASE("display a square", "[FrameDisplay]")
//{
//    auto S = createSquare({0,0.5,0},1.0f);
//    auto [nodes, edges] = S->getCurveFrame();
//    polyscope::init();
//    polyscope::options::groundPlaneMode = polyscope::GroundPlaneMode::None;
//    polyscope::registerCurveNetwork("square", nodes, edges);
//    polyscope::show();
//}

//TEST_CASE("display a double square", "[FrameDisplay]")
//{
//    auto S = createDoubleSquare({0,0,0},1.5f, 0.5f);
//    auto [nodes, edges] = S->getCurveFrame();
//    S->printFaces();
//    polyscope::init();
//    polyscope::options::groundPlaneMode = polyscope::GroundPlaneMode::None;
//    polyscope::registerCurveNetwork("square", nodes, edges);
//    polyscope::show();
//}

//TEST_CASE("display a cube generated by sweep", "[FrameDisplay]")
//{
//    auto S = createSquare({0,0,0}, 1.0f);
//    sweep(S->face(), {0,0,1},1.0f);
//    S->printFaces();
//    auto [nodes, edges] = S->getCurveFrame();
//    polyscope::init();
//    polyscope::options::groundPlaneMode = polyscope::GroundPlaneMode::None;
//    polyscope::registerCurveNetwork("cube", nodes, edges);
//    polyscope::show();
//}

//TEST_CASE("display a torus with a hole generated by sweep", "[FrameDisplay]")
//{
//    auto S = createDoubleSquare({0,0,0}, 1.5f, 0.5f);
//    sweep(S->face()->next(), {0,0,1},1.0f);
////    test_consistency(S);
//    S->printFaces();
//    auto [nodes, edges] = S->getCurveFrame();
//    polyscope::init();
//    polyscope::options::groundPlaneMode = polyscope::GroundPlaneMode::None;
//    polyscope::registerCurveNetwork("cube", nodes, edges);
//    polyscope::show();
//}

//TEST_CASE("display a cube generated by sweep", "[MeshDisplay]")
//{
//    auto S = createSquare({0,0,0},  1.0f);
//    sweep(S->face(), {0,0,1}, 1.0f);
//    auto [V, F] = S->getTriangulation();
//    std::cout << V << std::endl;
//    std::cout << F << std::endl;
//    polyscope::init();
////    polyscope::options::groundPlaneMode = polyscope::GroundPlaneMode::None;
//    polyscope::registerSurfaceMesh("cube", V, F);
//    polyscope::show();
//}

TEST_CASE("display a torus generated by sweep", "[MeshDisplay]")
{
    auto S = createDoubleSquare({0,0,0},  1.5f, 0.5f);
    test_consistency(S);
    sweep(S->face(), {0,0,1}, 1.0f);
    test_consistency(S);
    S->printFaces();
    auto [V, F] = S->getTriangulation();
    polyscope::init();
//    polyscope::options::groundPlaneMode = polyscope::GroundPlaneMode::None;
    auto mesh = polyscope::registerSurfaceMesh("cube", V, F);
    mesh->setBackFacePolicy(polyscope::BackFacePolicy::Custom);
    polyscope::show();
}
